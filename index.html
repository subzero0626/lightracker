<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIGHT TRACKER</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #gameArea {
            width: 100vw;
            height: 100vh;
            background: #1a1a2e;
            position: relative;
            overflow: hidden;
            display: none; /* 기본적으로 숨김 */
            cursor: none; /* 게임 화면에서만 커서 숨김 */
        }

        #gameArea.active {
            display: block; /* 활성화 시 표시 */
        }

        #cursorGauge {
            width: 20px;
            height: 20px;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            display: none; /* 기본적으로 숨김 */
        }

        #cursorGauge svg {
            display: block;
        }

        #gaugeBackground {
            display: none;
        }

        #character {
            width: 50px;
            height: 50px;
            background: #e74c3c;
            opacity: 0.8;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 1;
            transition: filter 0.3s ease;
        }

        #blueCircle {
            width: 50px;
            height: 50px;
            background: #3498db;
            opacity: 0.8;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 1;
            transition: filter 0.3s ease;
        }

        #lightPlatform {
            width: 375px;
            height: 375px;
            position: absolute;
            left: 0;
            top: 0;
            border-radius: 50%;
            background: rgba(255, 200, 100, 0.4);
            pointer-events: none;
            z-index: 2;
        }

        .topGauge {
            width: 100px;
            height: 8px;
            background: rgba(128, 128, 128, 0.3);
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 4px;
            overflow: hidden;
            z-index: 1000;
            display: none; /* 기본적으로 숨김 */
        }
        


        .topGauge.gauge1 {
            margin-left: -165px;
        }

        .topGauge.gauge2 {
            margin-left: -55px;
        }

        .topGauge.gauge3 {
            margin-left: 55px;
        }

        .topGauge.gauge4 {
            margin-left: 165px;
        }

        .topGaugeFill {
            width: 0%;
            height: 100%;
            background: rgba(128, 128, 128, 0.9);
            transition: width 0.1s linear;
            border-radius: 4px;
        }

        .healthGauge {
            width: 200px;
            height: 12px;
            background: rgba(128, 128, 128, 0.3);
            position: fixed;
            top: 30px;
            border-radius: 6px;
            overflow: hidden;
            z-index: 1001;
            display: none; /* 기본적으로 숨김 */
        }

        #playerHealthGauge {
            left: 30px;
        }

        #enemyHealthGauge {
            right: 30px;
        }

        .healthGaugeFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #e74c3c, #c0392b);
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        #enemyHealthFill {
            background: linear-gradient(to right, #3498db, #2980b9);
        }

        #roundEndScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.3);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: none;
        }
        
        #upgradeOrbsContainer {
            pointer-events: auto;
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .upgradeOrb {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            position: absolute;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(200, 150, 255, 0.6));
            box-shadow: 0 0 20px rgba(200, 150, 255, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.2s ease;
            transform-origin: center;
        }

        .upgradeOrb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(200, 150, 255, 1), inset 0 0 30px rgba(255, 255, 255, 0.5);
        }

        .upgradeOrb.selected {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .orbFlash {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            animation: flashGlow 0.5s ease-out;
            transform: translate(-50%, -50%);
        }
        
        @keyframes flashGlow {
            0% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(1.0);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        #roundInfo {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            z-index: 1002;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none; /* 기본적으로 숨김 */
        }

        /* 메인 화면 스타일 */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 20000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            cursor: default; /* 메인 화면에서 커서 표시 */
        }

        #mainMenu.hidden {
            display: none;
        }

        .menuBackground {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .floatingLight {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 200, 100, 0.4), transparent);
            filter: blur(40px);
            animation: floatLight 8s ease-in-out infinite;
        }

        .floatingLight:nth-child(1) {
            top: 20%;
            left: 10%;
            animation-delay: 0s;
        }

        .floatingLight:nth-child(2) {
            top: 60%;
            right: 15%;
            animation-delay: 2s;
        }

        .floatingLight:nth-child(3) {
            bottom: 20%;
            left: 50%;
            animation-delay: 4s;
        }

        @keyframes floatLight {
            0%, 100% {
                transform: translate(0, 0) scale(1);
                opacity: 0.4;
            }
            50% {
                transform: translate(50px, -50px) scale(1.2);
                opacity: 0.6;
            }
        }

        .gameTitle {
            font-size: 72px;
            font-weight: bold;
            color: #fff;
            text-shadow: 
                0 0 20px rgba(255, 200, 100, 0.8),
                0 0 40px rgba(255, 200, 100, 0.6),
                0 0 60px rgba(255, 200, 100, 0.4),
                2px 2px 10px rgba(0, 0, 0, 0.8);
            margin-bottom: 20px;
            letter-spacing: 4px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 
                    0 0 20px rgba(255, 200, 100, 0.8),
                    0 0 40px rgba(255, 200, 100, 0.6),
                    0 0 60px rgba(255, 200, 100, 0.4),
                    2px 2px 10px rgba(0, 0, 0, 0.8);
            }
            100% {
                text-shadow: 
                    0 0 30px rgba(255, 200, 100, 1),
                    0 0 60px rgba(255, 200, 100, 0.8),
                    0 0 90px rgba(255, 200, 100, 0.6),
                    2px 2px 10px rgba(0, 0, 0, 0.8);
            }
        }

        .gameSubtitle {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 60px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .menuButton {
            padding: 18px 50px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            background: transparent;
            border: none;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            box-shadow: none;
            margin: 10px;
            letter-spacing: 2px;
        }

        .menuButton:hover {
            color: rgba(255, 200, 100, 1);
            text-shadow: 
                0 0 20px rgba(255, 200, 100, 0.8),
                1px 1px 3px rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }

        .menuButton:active {
            transform: scale(0.98);
        }

        .menuContent {
            position: relative;
            z-index: 10;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 멀티플레이어 UI 스타일 */
        #multiplayerMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20001;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #multiplayerMenu.active {
            display: flex;
        }

        .multiplayerContent {
            background: rgba(26, 26, 46, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255, 200, 100, 0.6);
            box-shadow: 0 0 30px rgba(255, 200, 100, 0.3);
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .multiplayerTitle {
            font-size: 32px;
            color: #fff;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 200, 100, 0.8);
        }

        .roomCodeInput {
            width: 100%;
            padding: 15px;
            font-size: 24px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 200, 100, 0.6);
            border-radius: 10px;
            color: #fff;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }
        
        #joinRoomSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        #createRoomSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .roomCodeInput:focus {
            outline: none;
            border-color: rgba(255, 200, 100, 0.9);
            box-shadow: 0 0 20px rgba(255, 200, 100, 0.5);
        }

        .roomCodeDisplay {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            margin: 30px 0;
            letter-spacing: 10px;
            text-shadow: 0 0 20px rgba(255, 200, 100, 0.8);
        }

        .statusText {
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin: 20px 0;
            font-size: 18px;
        }

        .backButton {
            position: absolute;
            bottom: -80px;
            padding: 12px 30px;
            font-size: 18px;
        }

        /* 카운트다운 스타일 */
        #countdown {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 15000;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #countdown.active {
            display: flex;
        }

        .countdownNumber {
            font-size: 150px;
            font-weight: bold;
            color: #fff;
            text-shadow: 
                0 0 30px rgba(255, 200, 100, 1),
                0 0 60px rgba(255, 200, 100, 0.8),
                0 0 90px rgba(255, 200, 100, 0.6),
                2px 2px 10px rgba(0, 0, 0, 0.8);
            animation: countdownPulse 1s ease-out;
            letter-spacing: 10px;
        }

        @keyframes countdownPulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.8;
            }
        }

        .countdownText {
            font-size: 36px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            animation: fadeInOut 1s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% {
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
        }

    </style>
</head>
<body>
    <!-- 메인 메뉴 -->
    <div id="mainMenu">
        <div class="menuBackground">
            <div class="floatingLight"></div>
            <div class="floatingLight"></div>
            <div class="floatingLight"></div>
        </div>
        <div class="menuContent">
            <h1 class="gameTitle">LIGHT TRACKER</h1>
            <p class="gameSubtitle">빛을 따라가라</p>
            <button class="menuButton" id="createRoomMainButton">방 만들기</button>
            <button class="menuButton" id="joinRoomMainButton">방 입장하기</button>
        </div>
    </div>

    <!-- 멀티플레이어 메뉴 -->
    <div id="multiplayerMenu">
        <div class="multiplayerContent">
            <h2 class="multiplayerTitle">멀티플레이</h2>
            <div id="createRoomSection">
                <button class="menuButton" id="createRoomButton">방 만들기</button>
                <div id="roomCodeDisplay" class="roomCodeDisplay" style="display: none;"></div>
                <div id="createRoomStatus" class="statusText"></div>
            </div>
            <div id="joinRoomSection">
                <input type="text" id="roomCodeInput" class="roomCodeInput" placeholder="5자리 숫자 입력" maxlength="5" autocomplete="off" inputmode="numeric">
                <button class="menuButton" id="joinRoomButton">입장하기</button>
                <div id="joinRoomStatus" class="statusText"></div>
            </div>
            <div id="waitingSection" style="display: none;">
                <div class="statusText">상대방을 기다리는 중...</div>
            </div>
            <button class="menuButton backButton" id="backToMainButton">메인으로</button>
        </div>
    </div>

    <!-- 카운트다운 화면 -->
    <div id="countdown">
        <div class="countdownNumber" id="countdownNumber">3</div>
        <div class="countdownText" id="countdownText">라운드 시작</div>
    </div>

    <div class="topGauge gauge1">
        <div class="topGaugeFill" id="gauge1"></div>
    </div>
    <div class="topGauge gauge2">
        <div class="topGaugeFill" id="gauge2"></div>
    </div>
    <div class="topGauge gauge3">
        <div class="topGaugeFill" id="gauge3"></div>
    </div>
    <div class="topGauge gauge4">
        <div class="topGaugeFill" id="gauge4"></div>
    </div>
    <div class="healthGauge" id="playerHealthGauge">
        <div class="healthGaugeFill" id="playerHealthFill"></div>
    </div>
    <div class="healthGauge" id="enemyHealthGauge">
        <div class="healthGaugeFill" id="enemyHealthFill"></div>
    </div>
    <div id="roundInfo">Round 1</div>
    <div id="roundEndScreen">
        <div id="upgradeOrbsContainer"></div>
    </div>
    <div id="gameArea">
        <div id="lightPlatform"></div>
        <div id="character"></div>
        <div id="blueCircle"></div>
        <div id="cursorGauge">
            <svg width="20" height="20" viewBox="0 0 20 20">
                <circle cx="10" cy="10" r="8" fill="none" stroke="rgba(255, 255, 255, 0.3)" stroke-width="4.5"/>
                <circle cx="10" cy="10" r="8" fill="none" stroke="rgba(128, 128, 128, 0.9)" stroke-width="4.5" 
                        stroke-dasharray="50.27" 
                        stroke-dashoffset="0" 
                        transform="rotate(-90 10 10)"
                        id="gaugeBackground"/>
                <circle cx="10" cy="10" r="8" fill="none" stroke="rgba(255, 255, 255, 0.9)" stroke-width="4.5" 
                        stroke-dasharray="50.27" 
                        stroke-dashoffset="50.27" 
                        transform="rotate(-90 10 10)"
                        id="gaugeCircle"/>
            </svg>
        </div>
    </div>

    <script>
        // 메인 메뉴 요소
        const mainMenu = document.getElementById('mainMenu');
        const createRoomMainButton = document.getElementById('createRoomMainButton');
        const joinRoomMainButton = document.getElementById('joinRoomMainButton');
        
        // 멀티플레이어 요소
        const multiplayerMenu = document.getElementById('multiplayerMenu');
        const createRoomButton = document.getElementById('createRoomButton');
        const joinRoomButton = document.getElementById('joinRoomButton');
        const backToMainButton = document.getElementById('backToMainButton');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const createRoomSection = document.getElementById('createRoomSection');
        const joinRoomSection = document.getElementById('joinRoomSection');
        const waitingSection = document.getElementById('waitingSection');
        const createRoomStatus = document.getElementById('createRoomStatus');
        const joinRoomStatus = document.getElementById('joinRoomStatus');
        
        // ========== PeerJS 멀티플레이어 연결 로직 (완전히 새로 작성) ==========
        
        // PeerJS 관련 변수
        let peer = null;
        let conn = null;
        let isHost = false;
        let isConnected = false;
        let myPeerId = null;
        let roomCode = '';
        let guestConnectionRetryTimer = null;
        let guestConnectionRetryCount = 0;
        const MAX_RETRY_COUNT = 100; // 최대 100회 재시도
        
        // 5자리 숫자 방 코드 생성
        function generateRoomCode() {
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += Math.floor(Math.random() * 10);
            }
            return code;
        }
        
        // 기존 연결 정리
        function cleanupConnection() {
            if (conn) {
                try {
                    conn.close();
                } catch (e) {}
                conn = null;
            }
            if (peer) {
                try {
                    peer.destroy();
                } catch (e) {}
                peer = null;
            }
            if (guestConnectionRetryTimer) {
                clearTimeout(guestConnectionRetryTimer);
                guestConnectionRetryTimer = null;
            }
            isConnected = false;
            guestConnectionRetryCount = 0;
        }
        
        // 호스트: 방 생성
        function createRoom() {
            cleanupConnection();
            isHost = true;
            isConnected = false;
            roomCode = generateRoomCode();
            
            console.log('Creating room with code:', roomCode);
            createRoomStatus.textContent = '방 생성 중...';
            roomCodeDisplay.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            
            // Peer 생성 (방 코드를 Peer ID로 사용)
            peer = new Peer(roomCode, {
                debug: 2,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            // Peer 열림 이벤트
            peer.on('open', (id) => {
                myPeerId = id;
                console.log('Host Peer opened. ID:', id, 'Room code:', roomCode);
                createRoomStatus.textContent = '✅ 방이 생성되었습니다! 방 코드를 상대방에게 알려주세요.';
            });
            
            // 상대방 연결 수신
            peer.on('connection', (connection) => {
                console.log('Host: Incoming connection received');
                if (conn && conn.open) {
                    connection.close();
                    return;
                }
                
                conn = connection;
                setupConnectionHandlers();
                createRoomStatus.textContent = '✅ 상대방이 입장했습니다!';
            });
            
            // Peer 에러 처리
            peer.on('error', (err) => {
                console.error('Host Peer error:', err);
                if (err.type === 'unavailable-id') {
                    // 방 코드가 이미 사용 중이면 새 코드 생성
                    createRoomStatus.textContent = '방 코드 충돌. 새 코드 생성 중...';
                    setTimeout(() => {
                        createRoom();
                    }, 1000);
                } else {
                    createRoomStatus.textContent = '오류: ' + (err.message || err.type);
                }
            });
        }
        
        // 게스트: 방 입장
        function joinRoom(code) {
            cleanupConnection();
            isHost = false;
            isConnected = false;
            roomCode = code;
            guestConnectionRetryCount = 0;
            
            console.log('Joining room with code:', code);
            joinRoomStatus.textContent = 'Peer 초기화 중...';
            
            // Peer 생성 (자동 ID)
            peer = new Peer({
                debug: 2,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            // Peer 열림 이벤트
            peer.on('open', (id) => {
                myPeerId = id;
                console.log('Guest Peer opened. ID:', id, 'Connecting to:', roomCode);
                joinRoomStatus.textContent = '상대방에게 연결 중...';
                
                // 즉시 연결 시도
                attemptGuestConnection();
            });
            
            // Peer 에러 처리
            peer.on('error', (err) => {
                console.error('Guest Peer error:', err);
                if (err.type !== 'peer-unavailable') {
                    joinRoomStatus.textContent = '오류: ' + (err.message || err.type);
                }
            });
        }
        
        // 게스트: 연결 시도 (재시도 포함)
        function attemptGuestConnection() {
            if (isConnected) {
                console.log('Already connected');
                return;
            }
            
            if (!peer || !peer.open) {
                console.log('Peer not ready, retrying...');
                guestConnectionRetryTimer = setTimeout(() => {
                    attemptGuestConnection();
                }, 500);
                return;
            }
            
            if (!roomCode) {
                joinRoomStatus.textContent = '방 코드가 없습니다.';
                return;
            }
            
            guestConnectionRetryCount++;
            console.log('Guest connection attempt', guestConnectionRetryCount, 'to room:', roomCode);
            joinRoomStatus.textContent = '연결 시도 중... (' + guestConnectionRetryCount + '회)';
            
            // 기존 연결 정리
            if (conn) {
                try {
                    conn.close();
                } catch (e) {}
                conn = null;
            }
            
            try {
                // 연결 생성
                conn = peer.connect(roomCode, {
                    reliable: true,
                    serialization: 'json'
                });
                
                if (!conn) {
                    throw new Error('Failed to create connection');
                }
                
                // 연결 에러 핸들러
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    if (err.type === 'peer-unavailable' || err.message?.includes('Could not connect')) {
                        // 재시도
                        if (guestConnectionRetryCount < MAX_RETRY_COUNT) {
                            joinRoomStatus.textContent = '상대방을 찾는 중... (' + guestConnectionRetryCount + '/' + MAX_RETRY_COUNT + ')';
                            guestConnectionRetryTimer = setTimeout(() => {
                                attemptGuestConnection();
                            }, 1000);
                        } else {
                            joinRoomStatus.textContent = '방을 찾을 수 없습니다. 방 코드를 확인해주세요.';
                        }
                    } else {
                        joinRoomStatus.textContent = '연결 오류: ' + (err.message || err.type);
                    }
                });
                
                // 연결 핸들러 설정
                setupConnectionHandlers();
                
            } catch (err) {
                console.error('Connection attempt error:', err);
                if (guestConnectionRetryCount < MAX_RETRY_COUNT) {
                    joinRoomStatus.textContent = '연결 실패. 재시도 중... (' + guestConnectionRetryCount + '/' + MAX_RETRY_COUNT + ')';
                    guestConnectionRetryTimer = setTimeout(() => {
                        attemptGuestConnection();
                    }, 1000);
                } else {
                    joinRoomStatus.textContent = '연결 실패: ' + (err.message || '알 수 없는 오류');
                }
            }
        }
        
        // 연결 핸들러 설정
        function setupConnectionHandlers() {
            if (!conn) {
                console.error('setupConnectionHandlers: conn is null');
                return;
            }
            
            // 연결 열림
            conn.on('open', () => {
                console.log('Connection opened!');
                isConnected = true;
                guestConnectionRetryCount = 0;
                
                if (guestConnectionRetryTimer) {
                    clearTimeout(guestConnectionRetryTimer);
                    guestConnectionRetryTimer = null;
                }
                
                if (isHost) {
                    createRoomStatus.textContent = '✅ 연결 완료! 게임을 시작합니다...';
                } else {
                    joinRoomStatus.textContent = '✅ 연결 완료! 게임을 시작합니다...';
                }
                
                // 게임 시작
                setTimeout(() => {
                    startMultiplayerGame();
                }, 500);
            });
            
            // 데이터 수신
            conn.on('data', (data) => {
                try {
                    handleMultiplayerData(data);
                } catch (err) {
                    console.error('Error handling data:', err);
                }
            });
            
            // 연결 종료
            conn.on('close', () => {
                console.log('Connection closed');
                isConnected = false;
                if (!gamePaused) {
                    alert('상대방과의 연결이 끊어졌습니다.');
                    resetMultiplayer();
                }
            });
            
            // 연결 에러
            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }
        
        // 멀티플레이어 데이터 처리
        function handleMultiplayerData(data) {
            switch(data.type) {
                case 'position':
                    // 상대방 위치 업데이트
                    blueX = data.x;
                    blueY = data.y;
                    blueCircle.style.left = blueX + 'px';
                    blueCircle.style.top = blueY + 'px';
                    break;
                case 'health':
                    // 상대방 체력 업데이트
                    // 호스트가 받으면: 게스트(파란색)의 체력
                    // 게스트가 받으면: 호스트(빨간색)의 체력
                    if (isHost) {
                        // 호스트: 상대방(게스트)은 파란색이므로 enemyHealth에 저장
                        enemyHealth = data.health;
                    } else {
                        // 게스트: 상대방(호스트)은 빨간색이므로 enemyHealth에 저장
                        enemyHealth = data.health;
                    }
                    // 체력 게이지 업데이트는 updateHealth에서 처리
                    break;
                case 'gameState':
                    // 호스트의 게임 상태 동기화 (게스트만 수신)
                    if (!isHost) {
                        // 장판 위치
                        platformX = data.platformX;
                        platformY = data.platformY;
                        platformSizeMultiplier = data.platformSizeMultiplier;
                        platformSpeedMultiplier = data.platformSpeedMultiplier;
                        
                        // 게이지 상태
                        currentGaugeLevel = data.currentGaugeLevel;
                        topGauge1StartTime = data.topGauge1StartTime;
                        topGauge2StartTime = data.topGauge2StartTime;
                        topGauge3StartTime = data.topGauge3StartTime;
                        topGauge4StartTime = data.topGauge4StartTime;
                        gauge1Completed = data.gauge1Completed;
                        gauge2Completed = data.gauge2Completed;
                        gauge3Completed = data.gauge3Completed;
                        gauge4Completed = data.gauge4Completed;
                        
                        // 게이지 UI 업데이트
                        topGauge1.style.width = data.gauge1Progress + '%';
                        topGauge2.style.width = data.gauge2Progress + '%';
                        topGauge3.style.width = data.gauge3Progress + '%';
                        topGauge4.style.width = data.gauge4Progress + '%';
                        
                        // 장판 UI 업데이트
                        const platformDisplaySize = platformSize * platformSizeMultiplier;
                        lightPlatform.style.width = platformDisplaySize + 'px';
                        lightPlatform.style.height = platformDisplaySize + 'px';
                        lightPlatform.style.left = platformX + 'px';
                        lightPlatform.style.top = platformY + 'px';
                    }
                    break;
                case 'roundEnd':
                    // 라운드 종료 동기화
                    if (!isHost) {
                        playerWins = data.playerWins;
                        enemyWins = data.enemyWins;
                        endRound(data.winner);
                    }
                    break;
                case 'roundStart':
                    // 라운드 시작 동기화
                    if (!isHost) {
                        currentRound = data.currentRound;
                        playerWins = data.playerWins;
                        enemyWins = data.enemyWins;
                        roundInfo.textContent = `Round ${currentRound}`;
                        // 게임 상태 리셋 (startNextRound를 호출하지 않고 직접 리셋)
                        roundEndScreen.style.display = 'none';
                        isRoundEnded = false;
                        gamePaused = false;
                        currentHealth = maxHealth;
                        enemyHealth = maxHealth;
                        // 체력 게이지 업데이트: 빨간색(왼쪽), 파란색(오른쪽)
                        if (isHost) {
                            playerHealthFill.style.width = '100%'; // 빨간색
                            enemyHealthFill.style.width = '100%'; // 파란색
                        } else {
                            playerHealthFill.style.width = '100%'; // 빨간색(상대방)
                            enemyHealthFill.style.width = '100%'; // 파란색(자신)
                        }
                        lightPlatform.style.display = 'block';
                        gauge1Completed = false;
                        gauge2Completed = false;
                        gauge3Completed = false;
                        gauge4Completed = false;
                        topGauge1.style.width = '0%';
                        topGauge2.style.width = '0%';
                        topGauge3.style.width = '0%';
                        topGauge4.style.width = '0%';
                        platformSizeMultiplier = 1.0;
                        platformSpeedMultiplier = 1.0;
                        platformSizeChangeActive = false;
                        gauge2SizeReduced = false;
                        gauge4SizeReduced = false;
                        currentGaugeLevel = 1;
                        const pos = initializePosition();
                        x = pos.x;
                        y = pos.y;
                        targetX = x;
                        targetY = y;
                        // 호스트 위치를 blueCircle에 설정 (빨간색 플레이어)
                        if (data.hostX !== undefined && data.hostY !== undefined) {
                            blueX = data.hostX;
                            blueY = data.hostY;
                        } else {
                            blueX = pos.blueX;
                            blueY = pos.blueY;
                        }
                        blueVelocityX = 0;
                        blueVelocityY = 0;
                        character.style.left = x + 'px';
                        character.style.top = y + 'px';
                        blueCircle.style.left = blueX + 'px';
                        blueCircle.style.top = blueY + 'px';
                        
                        // 초기 위치 즉시 동기화
                        if (conn) {
                            conn.send({
                                type: 'position',
                                x: x,
                                y: y
                            });
                        }
                        platformX = window.innerWidth / 2 - platformRadius;
                        platformY = window.innerHeight / 2 - platformRadius;
                        platformDirectionX = (Math.random() - 0.5) * 2;
                        platformDirectionY = (Math.random() - 0.5) * 2;
                        dirLength = Math.sqrt(platformDirectionX * platformDirectionX + platformDirectionY * platformDirectionY);
                        platformDirectionX /= dirLength;
                        platformDirectionY /= dirLength;
                        platformDirectionChangeTime = Date.now();
                        platformDirectionDuration = 5000 + Math.random() * 5000;
                        startCountdown(() => {
                            const now = Date.now();
                            topGauge1StartTime = now;
                            topGauge2StartTime = now + topGaugeDuration;
                            topGauge3StartTime = now + topGaugeDuration * 2;
                            topGauge4StartTime = now + topGaugeDuration * 3;
                        });
                    }
                    break;
                case 'orbSelected':
                    // 상대방이 구슬을 선택했을 때 동기화
                    const allOrbs = Array.from(document.querySelectorAll('.upgradeOrb'));
                    if (allOrbs[data.orbIndex] !== undefined) {
                        const selectedOrb = allOrbs[data.orbIndex];
                        // 빛나는 효과 생성
                        const flash = document.createElement('div');
                        flash.className = 'orbFlash';
                        const orbColor = 'rgba(200, 150, 255, 0.6)';
                        flash.style.background = `radial-gradient(circle, ${orbColor}, transparent)`;
                        flash.style.boxShadow = `0 0 70px ${orbColor}, 0 0 100px ${orbColor}`;
                        const orbRect = selectedOrb.getBoundingClientRect();
                        flash.style.left = (orbRect.left + orbRect.width / 2) + 'px';
                        flash.style.top = (orbRect.top + orbRect.height / 2) + 'px';
                        upgradeOrbsContainer.appendChild(flash);
                        setTimeout(() => {
                            flash.remove();
                        }, 500);
                        
                        // 구슬 제거
                        selectedOrb.remove();
                        
                        // 선택된 구슬 정보 저장
                        selectedOrbs.push({
                            player: data.player,
                            effect: data.effect,
                            value: data.value
                        });
                        
                        // 다음 플레이어 차례로 변경
                        if (selectedOrbs.length === 1) {
                            selectionTurn = roundEndReason === 'player' ? 'player' : 'enemy';
                        } else {
                            // 두 플레이어 모두 선택 완료 - 다음 라운드 시작
                            waitingForSelection = false;
                            startNextRound();
                        }
                    }
                    break;
            }
        }
        
        // 멀티플레이어 게임 시작
        function startMultiplayerGame() {
            mainMenu.classList.add('hidden');
            multiplayerMenu.classList.remove('active');
            gameArea.classList.add('active');
            document.body.style.cursor = 'none';
            
            topGaugeElements.forEach(el => el.style.display = 'block');
            healthGaugeElements.forEach(el => el.style.display = 'block');
            roundInfo.style.display = 'block';
            cursorGauge.style.display = 'block';
            
            // 플레이어 색상 설정: 호스트 = 빨간색, 게스트 = 파란색
            if (isHost) {
                // 호스트는 빨간색 플레이어
                character.style.background = '#e74c3c';
                // 상대방(게스트)은 파란색으로 표시
                blueCircle.style.background = '#3498db';
            } else {
                // 게스트는 파란색 플레이어
                character.style.background = '#3498db';
                // 상대방(호스트)은 빨간색으로 표시
                blueCircle.style.background = '#e74c3c';
            }
            
            // 멀티플레이어 모드: 초기 위치 설정 (init() 전에 설정)
            const pos = initializePosition();
            x = pos.x;
            y = pos.y;
            targetX = x;
            targetY = y;
            blueX = pos.blueX;
            blueY = pos.blueY;
            character.style.left = x + 'px';
            character.style.top = y + 'px';
            blueCircle.style.left = blueX + 'px';
            blueCircle.style.top = blueY + 'px';
            
            init();
            
            startCountdown(() => {
                const now = Date.now();
                topGauge1StartTime = now;
                topGauge2StartTime = now + topGaugeDuration;
                topGauge3StartTime = now + topGaugeDuration * 2;
                topGauge4StartTime = now + topGaugeDuration * 3;
            });
        }
        
        // 멀티플레이어 리셋
        function resetMultiplayer() {
            cleanupConnection();
            isHost = false;
            // 플레이어 색상 초기화
            character.style.background = '#e74c3c'; // 빨간색으로 복원
            blueCircle.style.background = '#3498db'; // 파란색으로 복원
            multiplayerMenu.classList.remove('active');
            mainMenu.classList.remove('hidden');
            createRoomSection.style.display = 'block';
            joinRoomSection.style.display = 'block';
            waitingSection.style.display = 'none';
            roomCodeDisplay.style.display = 'none';
            createRoomButton.style.display = 'block';
            createRoomStatus.textContent = '';
            joinRoomStatus.textContent = '';
            roomCodeInput.value = '';
        }
        
        // 방 만들기 버튼 (멀티플레이어 메뉴)
        createRoomButton.addEventListener('click', () => {
            createRoomButton.style.display = 'none';
            waitingSection.style.display = 'block';
            createRoom();
        });
        
        // 방 입장 버튼 (멀티플레이어 메뉴)
        joinRoomButton.addEventListener('click', () => {
            const code = roomCodeInput.value.trim();
            if (code.length !== 5 || !/^\d{5}$/.test(code)) {
                joinRoomStatus.textContent = '5자리 숫자 코드를 입력해주세요.';
                return;
            }
            joinRoom(code);
        });
        
        
        // 메인으로 돌아가기
        backToMainButton.addEventListener('click', () => {
            resetMultiplayer();
        });
        
        // 방 만들기/입장 토글
        const toggleRoomMode = () => {
            if (createRoomSection.style.display === 'none') {
                createRoomSection.style.display = 'block';
                joinRoomSection.style.display = 'none';
            } else {
                createRoomSection.style.display = 'none';
                joinRoomSection.style.display = 'block';
            }
        };
        
        // 방 코드 입력 필드에서 Enter 키 처리
        roomCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinRoomButton.click();
            }
            // 숫자만 입력 허용
            if (!/[0-9]/.test(e.key) && e.key !== 'Enter' && e.key !== 'Backspace' && e.key !== 'Delete') {
                e.preventDefault();
            }
        });
        
        // 방 코드 입력 필드를 숫자만 입력받도록 제한
        roomCodeInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, ''); // 숫자가 아닌 문자 제거
        });
        
        // 카운트다운 요소
        const countdown = document.getElementById('countdown');
        const countdownNumber = document.getElementById('countdownNumber');
        const countdownText = document.getElementById('countdownText');
        
        const character = document.getElementById('character');
        const blueCircle = document.getElementById('blueCircle');
        const lightPlatform = document.getElementById('lightPlatform');
        const gameArea = document.getElementById('gameArea');
        const cursorGauge = document.getElementById('cursorGauge');
        const gaugeCircle = document.getElementById('gaugeCircle');
        const gaugeBackground = document.getElementById('gaugeBackground');
        
        // 상단 게이지 요소들
        const topGauge1 = document.getElementById('gauge1');
        const topGauge2 = document.getElementById('gauge2');
        const topGauge3 = document.getElementById('gauge3');
        const topGauge4 = document.getElementById('gauge4');
        
        // 상단 게이지 관련 변수
        const topGaugeDuration = 20000; // 20초 (밀리초)
        let topGauge1StartTime = Date.now();
        let topGauge2StartTime = Date.now() + topGaugeDuration; // 20초 후 시작
        let topGauge3StartTime = Date.now() + topGaugeDuration * 2; // 40초 후 시작
        let topGauge4StartTime = Date.now() + topGaugeDuration * 3; // 60초 후 시작
        let gauge1Completed = false; // 게이지 1 완료 여부
        let gauge2Completed = false; // 게이지 2 완료 여부
        let gauge3Completed = false; // 게이지 3 완료 여부
        let gauge4Completed = false; // 게이지 4 완료 여부
        
        // 체력 시스템
        const playerHealthFill = document.getElementById('playerHealthFill');
        const enemyHealthFill = document.getElementById('enemyHealthFill');
        const maxHealth = 10;
        let currentHealth = maxHealth;
        let enemyHealth = maxHealth; // 상대 체력
        let lastDamageTime = Date.now();
        let lastEnemyDamageTime = Date.now();
        const damageInterval = 100; // 0.1초마다 데미지 (100ms)
        
        // 라운드 시스템
        const roundInfo = document.getElementById('roundInfo');
        const roundEndScreen = document.getElementById('roundEndScreen');
        const upgradeOrbsContainer = document.getElementById('upgradeOrbsContainer');
        let currentRound = 1;
        let playerWins = 0;
        let enemyWins = 0;
        let isRoundEnded = false;
        let roundEndReason = ''; // 'player' 또는 'enemy'
        let waitingForSelection = false;
        let selectionTurn = ''; // 'loser' 또는 'winner'
        let selectedOrbs = [];
        let gamePaused = false;
        let orbContactTimes = new Map(); // 구슬 접촉 시작 시간 추적 (구슬 요소 -> 접촉 시작 시간)
        const orbSelectionDuration = 2000; // 구슬 선택에 필요한 접촉 시간 (2초)
        
        // 게이지 효과 변수
        let currentGaugeLevel = 1; // 현재 활성화된 게이지 레벨
        let platformSizeMultiplier = 1.0; // 장판 크기 배수
        let platformSpeedMultiplier = 1.0; // 장판 속도 배수
        let platformSizeChangeStartTime = 0; // 장판 크기 변경 시작 시간
        let platformSizeChangeDuration = 5000; // 장판 크기 변경 지속 시간 (5초)
        let platformSizeChangeActive = false; // 장판 크기 변경 중인지
        let gauge2SizeReduced = false; // 게이지 2에서 크기 감소 적용 여부
        let gauge4SizeReduced = false; // 게이지 4에서 크기 감소 적용 여부
        let gauge2BaseMultiplier = 1.0; // 게이지 2 시작 시 기준 배수
        let gauge4BaseMultiplier = 1.0; // 게이지 4 시작 시 기준 배수

        const speed = 3; // 이동 속도
        const characterSize = 50; // 캐릭터 크기
        const radius = characterSize / 2; // 원의 반지름
        const pushForce = 0.3; // 밀기 힘 (더 부드럽게)
        const collisionPadding = 2; // 충돌 방지 여유 공간 (증가)
        
        // 빛 장판 관련 변수
        const platformSize = 375; // 빛 장판 크기 (300 * 1.25 = 375)
        const platformRadius = platformSize / 2; // 빛 장판 반지름
        const platformSpeed = 0.5; // 빛 장판 이동 속도 (느리게)
        const platformBoundaryMargin = 100; // 벽으로부터 이 거리만큼 가까워지면 중앙으로 이동
        let platformX = window.innerWidth / 2 - platformRadius; // 빛 장판 X 위치
        let platformY = window.innerHeight / 2 - platformRadius; // 빛 장판 Y 위치
        let platformDirectionX = (Math.random() - 0.5) * 2; // 랜덤 방향 X (-1 ~ 1)
        let platformDirectionY = (Math.random() - 0.5) * 2; // 랜덤 방향 Y (-1 ~ 1)
        // 방향 정규화
        let dirLength = Math.sqrt(platformDirectionX * platformDirectionX + platformDirectionY * platformDirectionY);
        platformDirectionX /= dirLength;
        platformDirectionY /= dirLength;
        
        // 방향 변경 타이머
        let platformDirectionChangeTime = Date.now();
        let platformDirectionDuration = 5000 + Math.random() * 5000; // 5~10초 (랜덤)
        
        // 초기 위치 계산 함수
        function initializePosition() {
            const centerX = window.innerWidth / 2 - characterSize / 2;
            // 장판의 중앙 y축에 위치
            const centerY = window.innerHeight / 2 - characterSize / 2;
            
            // 멀티플레이어 모드: 호스트(빨간색)는 오른쪽, 게스트(파란색)는 왼쪽
            // isHost가 설정되어 있으면 멀티플레이어 모드로 간주
            if (isHost !== undefined && (isHost === true || isHost === false)) {
                if (isHost) {
                    // 호스트(빨간색): 오른쪽
                    return { x: centerX + 100, y: centerY, blueX: centerX - 120, blueY: centerY };
                } else {
                    // 게스트(파란색): 왼쪽
                    return { x: centerX - 120, y: centerY, blueX: centerX + 100, blueY: centerY };
                }
            } else {
                // 싱글플레이어 모드
                return { x: centerX - 80, y: centerY, blueX: centerX + 100, blueY: centerY };
            }
        }
        
        let { x, y } = initializePosition();  // 캐릭터의 시작 위치 (중앙)
        let targetX = x; // 목표 X 위치
        let targetY = y; // 목표 Y 위치
        let prevX = x; // 이전 프레임의 X 위치
        let prevY = y; // 이전 프레임의 Y 위치
        let velocityX = 0; // 플레이어의 X 속도
        let velocityY = 0; // 플레이어의 Y 속도
        
        // 파란색 원 위치 및 속도
        let blueX = window.innerWidth / 2 - characterSize / 2 + 100; // 캐릭터 오른쪽에 배치
        let blueY = y; // 플레이어와 같은 y축
        let blueVelocityX = 0; // 파란 원의 X 속도
        let blueVelocityY = 0; // 파란 원의 Y 속도
        
        // 돌진 관련 변수
        let isDashing = false;
        let dashPhase = 'back'; // 'back' 또는 'forward'
        let dashDirection = { x: 0, y: 0 };
        let dashStartTime = 0;
        let dashStartX = 0;
        let dashStartY = 0;
        let dashForwardProgress = 0;
        let dashCooldownEndTime = 0; // 쿨타임 종료 시간
        const dashBackDuration = 100; // 0.1초 (밀리초)
        const dashBackDistance = 10; // 뒤로 가는 거리
        const dashForwardDistance = 100; // 앞으로 돌진 거리
        const dashForwardSpeed = 15; // 앞으로 돌진 속도 (픽셀/프레임)
        const dashCooldown = 1000; // 쿨타임 1초 (밀리초)
        const pushDistanceMultiplier = 1.75; // 돌진 시 밀리는 거리 배수 (돌진 거리의 1.75배)
        const pushDeceleration = 0.92; // 밀려날 때 감속 계수 (매 프레임 8% 감소)
        const circumference = 2 * Math.PI * 8; // 원의 둘레 (r=8) ≈ 50.27

        // 마우스 위치 추적 (항상 작동하도록 window에 등록)
        window.addEventListener('mousemove', (e) => {
            targetX = e.clientX - characterSize / 2;
            targetY = e.clientY - characterSize / 2;
            
            // 커서 게이지 위치 업데이트
            cursorGauge.style.left = e.clientX + 'px';
            cursorGauge.style.top = e.clientY + 'px';
        });

        // 게이지 업데이트 함수
        function updateGauge() {
            const now = Date.now();
            
            if (now < dashCooldownEndTime) {
                // 쿨타임 중: 회색 배경 표시 + 위에서부터 시계방향으로 하얀색 게이지 채워짐
                gaugeBackground.style.display = 'block'; // 회색 배경 표시
                
                // 쿨타임 진행도 계산 (1.0 = 시작, 0.0 = 끝)
                const cooldownProgress = (dashCooldownEndTime - now) / dashCooldown;
                
                // 위에서부터 시계방향으로 채워지도록 offset 계산
                // strokeDashoffset이 0이면 완전히 채워진 상태, circumference면 비어있는 상태
                const offset = circumference * cooldownProgress;
                gaugeCircle.style.strokeDashoffset = offset;
            } else {
                // 돌진 가능 상태: 하얀색 게이지가 완전히 채워져 있음
                gaugeBackground.style.display = 'none'; // 회색 배경 숨김
                gaugeCircle.style.strokeDashoffset = 0; // 하얀색 게이지 완전히 채워짐
            }
        }

        // 마우스 좌클릭 - 돌진
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !isDashing && Date.now() >= dashCooldownEndTime && !gamePaused) { // 좌클릭 (돌진 중이 아니고 쿨타임이 끝났을 때만, 게임이 일시정지되지 않았을 때만)
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0.1) {
                    // 현재 이동 방향 정규화
                    dashDirection.x = dx / distance;
                    dashDirection.y = dy / distance;
                    isDashing = true;
                    dashPhase = 'back';
                    dashStartTime = Date.now();
                    dashStartX = x;
                    dashStartY = y;
                    dashForwardProgress = 0;
                    
                    // 돌진 사용 시: 게이지를 즉시 회색으로 변경
                    gaugeBackground.style.display = 'block'; // 회색 배경 표시
                    gaugeCircle.style.strokeDashoffset = circumference; // 하얀색 게이지 비우기 (위에서부터 채워지기 시작)
                    
                    // 쿨타임 시작
                    dashCooldownEndTime = Date.now() + dashCooldown;
                }
            }
        });

        // 충돌 감지 및 밀기 함수 (속도 기반)
        function handleCollision() {
            // 두 원의 중심 좌표 계산
            const charCenterX = x + radius;
            const charCenterY = y + radius;
            const blueCenterX = blueX + radius;
            const blueCenterY = blueY + radius;
            
            // 두 원의 중심 사이 거리 계산
            const dx = charCenterX - blueCenterX;
            const dy = charCenterY - blueCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = radius * 2 + collisionPadding; // 최소 거리 (여유 공간 포함)
            
            // 충돌 감지 (거리가 최소 거리보다 작으면)
            if (distance < minDistance && distance > 0.01) {
                // 충돌 방향 벡터 정규화
                const normalX = dx / distance;
                const normalY = dy / distance;
                
                // 겹침 깊이 계산
                const overlap = minDistance - distance;
                
                // 돌진 중인지 확인
                if (isDashing && dashPhase === 'forward') {
                    // 돌진 중: 무조건 돌진 방향으로 상대를 밀어냄
                    // 밀리는 거리를 돌진 거리의 1.75배로 설정
                    // 마찰을 고려하여 초기 속도 계산
                    // 총 거리 = 초기속도 * f / (1 - f) (f = 마찰 계수)
                    // 초기속도 = 목표거리 * (1 - f) / f
                    const targetDistance = dashForwardDistance * pushDistanceMultiplier; // 100 * 1.75 = 175
                    const avgFriction = 0.94; // 평균 마찰 계수 (마찰 약간 증가)
                    const dashPushSpeed = targetDistance * (1 - avgFriction) / avgFriction;
                    
                    // 현재 속도 벡터와 돌진 방향 벡터의 내적 계산
                    const currentSpeedInDirection = blueVelocityX * dashDirection.x + blueVelocityY * dashDirection.y;
                    
                    // 현재 속도보다 새 속도가 크면 업데이트 (돌진 방향으로 밀기)
                    if (dashPushSpeed > currentSpeedInDirection) {
                        blueVelocityX = dashDirection.x * dashPushSpeed;
                        blueVelocityY = dashDirection.y * dashPushSpeed;
                    }
                } else {
                    // 일반 이동 중: 플레이어의 속도 계산
                    const playerSpeed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                    
                    // 플레이어의 속도를 충돌 방향으로 투영
                    const relativeVelocity = velocityX * normalX + velocityY * normalY;
                    
                    // 플레이어가 파란 원을 밀고 있는 경우 (상대 속도가 양수)
                    if (relativeVelocity > 0 && playerSpeed > 0.1) {
                        // 충돌 방향으로 파란 원을 밀어냄
                        blueVelocityX = normalX * playerSpeed;
                        blueVelocityY = normalY * playerSpeed;
                    }
                }
                
                // 겹침 해결 (즉시 분리) - 돌진 중에는 더 강하게 분리
                const separationRatio = (isDashing && dashPhase === 'forward') ? 1.0 : 0.6;
                const separationX = normalX * overlap * separationRatio;
                const separationY = normalY * overlap * separationRatio;
                
                // 플레이어는 적게 밀리고, 파란 원은 많이 밀려나도록
                // 돌진 중에는 플레이어를 거의 밀지 않음
                const playerPushRatio = (isDashing && dashPhase === 'forward') ? 0.1 : 0.3;
                const bluePushRatio = 1.0 - playerPushRatio;
                
                x += separationX * playerPushRatio;
                y += separationY * playerPushRatio;
                blueX -= separationX * bluePushRatio;
                blueY -= separationY * bluePushRatio;
            }
        }

        // 충돌 예측 함수 (이동 전 충돌 방지)
        function checkCollisionBeforeMove(newX, newY) {
            const charCenterX = newX + radius;
            const charCenterY = newY + radius;
            const blueCenterX = blueX + radius;
            const blueCenterY = blueY + radius;
            
            const dx = charCenterX - blueCenterX;
            const dy = charCenterY - blueCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = radius * 2 + collisionPadding;
            
            return distance < minDistance;
        }

        // 캐릭터 위치 업데이트 함수
        function updatePosition() {
            // 카운트다운 중에는 플레이어 이동 불가
            if (countdown.classList.contains('active')) {
                return;
            }
            
            let newX = x;
            let newY = y;
            
            if (isDashing) {
                const elapsed = Date.now() - dashStartTime;
                
                if (elapsed < dashBackDuration) {
                    // 0.1초 동안 뒤로 이동
                    const backProgress = elapsed / dashBackDuration;
                    newX = dashStartX - dashDirection.x * dashBackDistance * backProgress;
                    newY = dashStartY - dashDirection.y * dashBackDistance * backProgress;
                } else {
                    // 앞으로 돌진 (프레임 기반)
                    if (dashPhase === 'back') {
                        // 뒤로 가기 완료, 앞으로 돌진 시작
                        dashPhase = 'forward';
                        dashForwardProgress = 0;
                    }
                    
                    dashForwardProgress += dashForwardSpeed;
                    
                    if (dashForwardProgress < dashForwardDistance) {
                        newX = dashStartX - dashDirection.x * dashBackDistance + dashDirection.x * dashForwardProgress;
                        newY = dashStartY - dashDirection.y * dashBackDistance + dashDirection.y * dashForwardProgress;
                    } else {
                        // 돌진 완료
                        newX = dashStartX - dashDirection.x * dashBackDistance + dashDirection.x * dashForwardDistance;
                        newY = dashStartY - dashDirection.y * dashBackDistance + dashDirection.y * dashForwardDistance;
                        isDashing = false;
                        dashPhase = 'back';
                    }
                }
            } else {
                // 마우스 위치로 부드럽게 이동
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > speed) {
                    // 속도만큼 이동
                    newX = x + (dx / distance) * speed;
                    newY = y + (dy / distance) * speed;
                } else {
                    // 목표 위치에 도달
                    newX = targetX;
                    newY = targetY;
                }
            }
            
            // 플레이어 속도 계산
            velocityX = newX - x;
            velocityY = newY - y;
            
            x = newX;
            y = newY;

            // 충돌 처리 (밀기 효과) - 돌진 중에는 여러 번 반복하여 겹침 방지
            const collisionIterations = (isDashing && dashPhase === 'forward') ? 10 : 3;
            for (let i = 0; i < collisionIterations; i++) {
                handleCollision();
            }
            
            // 파란 원을 속도에 따라 이동
            blueX += blueVelocityX;
            blueY += blueVelocityY;
            
            // 파란 원의 속도 감소 (마찰 적용) - 자연스러운 점진적 감속
            const baseFriction = 0.94; // 기본 마찰 계수 (0.94 = 매 프레임 6% 감소, 마찰 약간 증가)
            const blueSpeed = Math.sqrt(blueVelocityX * blueVelocityX + blueVelocityY * blueVelocityY);
            
            // 속도가 빠를수록 더 빠르게 감속 (더 자연스러운 감속)
            // 돌진 충돌 시 목표 속도 계산 (거리 기반)
            const targetPushDistance = dashForwardDistance * pushDistanceMultiplier;
            const avgFriction = 0.94; // 평균 마찰 계수 약간 증가 (0.93 -> 0.94)
            const targetPushSpeed = targetPushDistance * (1 - avgFriction) / avgFriction;
            const speedFactor = Math.min(1.0, blueSpeed / targetPushSpeed);
            const friction = baseFriction - (speedFactor * 0.03); // 빠른 속도일 때 더 빠르게 감속
            
            blueVelocityX *= friction;
            blueVelocityY *= friction;
            
            // 속도가 매우 작으면 정지
            const finalBlueSpeed = Math.sqrt(blueVelocityX * blueVelocityX + blueVelocityY * blueVelocityY);
            if (finalBlueSpeed < 0.1) {
                blueVelocityX = 0;
                blueVelocityY = 0;
            }

            // 게임 영역 경계 체크
            const maxX = Math.max(0, window.innerWidth - characterSize);
            const maxY = Math.max(0, window.innerHeight - characterSize);

            x = Math.max(0, Math.min(x, maxX));
            y = Math.max(0, Math.min(y, maxY));
            
            // 파란색 원 경계 체크 (벽에 부딪히면 속도 반전)
            if (blueX <= 0 || blueX >= maxX) {
                blueVelocityX *= -0.8; // 약간의 반발력
                blueX = Math.max(0, Math.min(blueX, maxX));
            }
            if (blueY <= 0 || blueY >= maxY) {
                blueVelocityY *= -0.8; // 약간의 반발력
                blueY = Math.max(0, Math.min(blueY, maxY));
            }

            character.style.left = x + 'px';
            character.style.top = y + 'px';
            blueCircle.style.left = blueX + 'px';
            blueCircle.style.top = blueY + 'px';
            
            // 플레이어가 장판 안에 있는지 확인 (동적 장판 크기 반영)
            const charCenterX = x + radius;
            const charCenterY = y + radius;
            const currentPlatformRadius = platformRadius * platformSizeMultiplier;
            const platformCenterX = platformX + currentPlatformRadius;
            const platformCenterY = platformY + currentPlatformRadius;
            
            const dx = charCenterX - platformCenterX;
            const dy = charCenterY - platformCenterY;
            const distanceToPlatform = Math.sqrt(dx * dx + dy * dy);
            
            // 장판이 표시되어 있을 때만 어두워지는 효과 적용
            if (lightPlatform.style.display !== 'none') {
                // 장판 밖에 있으면 어둡게
                if (distanceToPlatform > currentPlatformRadius) {
                    character.style.filter = 'brightness(0.3)'; // 어둡게
                } else {
                    character.style.filter = 'brightness(1.0)'; // 밝게
                }
            }
            
            // 파란 원이 장판 안에 있는지 확인
            const blueCenterX = blueX + radius;
            const blueCenterY = blueY + radius;
            const blueDx = blueCenterX - platformCenterX;
            const blueDy = blueCenterY - platformCenterY;
            const blueDistanceToPlatform = Math.sqrt(blueDx * blueDx + blueDy * blueDy);
            
            // 장판이 표시되어 있을 때만 어두워지는 효과 적용
            if (lightPlatform.style.display !== 'none') {
                // 장판 밖에 있으면 어둡게
                if (blueDistanceToPlatform > currentPlatformRadius) {
                    blueCircle.style.filter = 'brightness(0.3)'; // 어둡게
                } else {
                    blueCircle.style.filter = 'brightness(1.0)'; // 밝게
                }
            }
            
            // 이전 위치 저장
            prevX = x;
            prevY = y;
        }

        // 빛 장판 위치 업데이트 함수
        function updateLightPlatform() {
            if (gamePaused) return; // 라운드 종료 시 장판 업데이트 중단
            
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const platformCenterX = platformX + platformRadius;
            const platformCenterY = platformY + platformRadius;
            
            // 벽으로부터의 거리 계산
            const distToLeft = platformCenterX;
            const distToRight = window.innerWidth - platformCenterX;
            const distToTop = platformCenterY;
            const distToBottom = window.innerHeight - platformCenterY;
            const minDistToWall = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            const now = Date.now();
            const elapsed = now - platformDirectionChangeTime;
            
            // 이동 전 경계 상태 확인
            const maxX = window.innerWidth - platformSize;
            const maxY = window.innerHeight - platformSize;
            const wasAtBoundary = (platformX <= 0 || platformX >= maxX || platformY <= 0 || platformY >= maxY);
            
            // 빛 장판 이동 (게이지 효과 적용)
            const currentPlatformSpeed = platformSpeed * platformSpeedMultiplier;
            platformX += platformDirectionX * currentPlatformSpeed;
            platformY += platformDirectionY * currentPlatformSpeed;
            
            // 경계 체크 (장판이 화면 밖으로 나가지 않도록)
            const currentPlatformSize = platformSize * platformSizeMultiplier;
            const currentMaxX = window.innerWidth - currentPlatformSize;
            const currentMaxY = window.innerHeight - currentPlatformSize;
            platformX = Math.max(0, Math.min(platformX, currentMaxX));
            platformY = Math.max(0, Math.min(platformY, currentMaxY));
            
            // 벽에 닿은 순간 감지 (이전에 경계에 없었는데 지금 경계에 있으면)
            const isAtBoundary = (platformX <= 0 || platformX >= maxX || platformY <= 0 || platformY >= maxY);
            
            if (isAtBoundary && !wasAtBoundary) {
                // 벽에 닿은 순간: 원래 이동 취소하고 중앙 방향으로 변경
                const newPlatformCenterX = platformX + platformRadius;
                const newPlatformCenterY = platformY + platformRadius;
                const dxToCenter = centerX - newPlatformCenterX;
                const dyToCenter = centerY - newPlatformCenterY;
                const distToCenter = Math.sqrt(dxToCenter * dxToCenter + dyToCenter * dyToCenter);
                
                if (distToCenter > 0) {
                    // 중앙 방향으로 이동
                    platformDirectionX = dxToCenter / distToCenter;
                    platformDirectionY = dyToCenter / distToCenter;
                    // 방향 변경 시간 리셋 (5~10초 동안 중앙으로 이동)
                    platformDirectionChangeTime = now;
                    platformDirectionDuration = 5000 + Math.random() * 5000;
                }
            } else if (elapsed >= platformDirectionDuration) {
                // 5~10초가 지나면 새로운 랜덤 방향 선택
                platformDirectionX = (Math.random() - 0.5) * 2;
                platformDirectionY = (Math.random() - 0.5) * 2;
                dirLength = Math.sqrt(platformDirectionX * platformDirectionX + platformDirectionY * platformDirectionY);
                platformDirectionX /= dirLength;
                platformDirectionY /= dirLength;
                
                // 새로운 방향 변경 시간 설정
                platformDirectionChangeTime = now;
                platformDirectionDuration = 5000 + Math.random() * 5000; // 5~10초 (랜덤)
            }
            
            // 빛 장판 크기 및 위치 업데이트 (게이지 효과 적용)
            const platformDisplaySize = platformSize * platformSizeMultiplier;
            lightPlatform.style.width = platformDisplaySize + 'px';
            lightPlatform.style.height = platformDisplaySize + 'px';
            lightPlatform.style.left = platformX + 'px';
            lightPlatform.style.top = platformY + 'px';
        }

        // 상단 게이지 업데이트 함수
        function updateTopGauges() {
            const now = Date.now();
            let gauge1Progress = 0;
            let gauge2Progress = 0;
            let gauge3Progress = 0;
            let gauge4Progress = 0;
            
            // 게이지 1 업데이트
            if (!gauge1Completed) {
                let gauge1Elapsed = now - topGauge1StartTime;
                if (gauge1Elapsed >= topGaugeDuration) {
                    gauge1Completed = true;
                    topGauge1.style.width = '100%';
                    gauge1Progress = 100;
                } else {
                    gauge1Progress = (gauge1Elapsed / topGaugeDuration) * 100;
                    topGauge1.style.width = gauge1Progress + '%';
                }
            } else {
                topGauge1.style.width = '100%';
                gauge1Progress = 100;
            }
            
            // 게이지 2 업데이트
            if (!gauge2Completed) {
                let gauge2Elapsed = now - topGauge2StartTime;
                if (gauge2Elapsed >= topGaugeDuration) {
                    gauge2Completed = true;
                    topGauge2.style.width = '100%';
                    gauge2Progress = 100;
                } else {
                    gauge2Progress = (gauge2Elapsed / topGaugeDuration) * 100;
                    topGauge2.style.width = gauge2Progress + '%';
                }
            } else {
                topGauge2.style.width = '100%';
                gauge2Progress = 100;
            }
            
            // 게이지 3 업데이트
            if (!gauge3Completed) {
                let gauge3Elapsed = now - topGauge3StartTime;
                if (gauge3Elapsed >= topGaugeDuration) {
                    gauge3Completed = true;
                    topGauge3.style.width = '100%';
                    gauge3Progress = 100;
                } else {
                    gauge3Progress = (gauge3Elapsed / topGaugeDuration) * 100;
                    topGauge3.style.width = gauge3Progress + '%';
                }
            } else {
                topGauge3.style.width = '100%';
                gauge3Progress = 100;
            }
            
            // 게이지 4 업데이트
            if (!gauge4Completed) {
                let gauge4Elapsed = now - topGauge4StartTime;
                if (gauge4Elapsed >= topGaugeDuration) {
                    gauge4Completed = true;
                    topGauge4.style.width = '100%';
                    gauge4Progress = 100;
                } else {
                    gauge4Progress = (gauge4Elapsed / topGaugeDuration) * 100;
                    topGauge4.style.width = gauge4Progress + '%';
                }
            } else {
                topGauge4.style.width = '100%';
                gauge4Progress = 100;
            }
            
            // 현재 활성화된 게이지 레벨 결정
            let newGaugeLevel = 1;
            if (gauge4Completed || gauge4Progress > 0) newGaugeLevel = 4;
            else if (gauge3Completed || gauge3Progress > 0) newGaugeLevel = 3;
            else if (gauge2Completed || gauge2Progress > 0) newGaugeLevel = 2;
            else if (gauge1Completed || gauge1Progress > 0) newGaugeLevel = 1;
            
            // 게이지 레벨 변경 시 효과 적용
            if (newGaugeLevel !== currentGaugeLevel) {
                currentGaugeLevel = newGaugeLevel;
                
                // 게이지 2: 장판 크기 15% 감소 시작 (한 번만)
                if (currentGaugeLevel === 2 && !gauge2SizeReduced && !platformSizeChangeActive) {
                    gauge2SizeReduced = true;
                    gauge2BaseMultiplier = platformSizeMultiplier;
                    platformSizeChangeActive = true;
                    platformSizeChangeStartTime = now;
                }
                
                // 게이지 3: 장판 속도 25% 증가
                if (currentGaugeLevel === 3) {
                    platformSpeedMultiplier = 1.25;
                } else if (currentGaugeLevel < 3) {
                    platformSpeedMultiplier = 1.0;
                }
                
                // 게이지 4: 장판 크기 15% 감소 시작 (한 번만)
                if (currentGaugeLevel === 4 && !gauge4SizeReduced && !platformSizeChangeActive) {
                    gauge4SizeReduced = true;
                    gauge4BaseMultiplier = platformSizeMultiplier;
                    platformSizeChangeActive = true;
                    platformSizeChangeStartTime = now;
                }
            }
            
            // 장판 크기 변경 처리
            if (platformSizeChangeActive) {
                const sizeChangeElapsed = now - platformSizeChangeStartTime;
                if (sizeChangeElapsed < platformSizeChangeDuration) {
                    // 5초에 걸쳐 15% 감소
                    const sizeChangeProgress = sizeChangeElapsed / platformSizeChangeDuration;
                    const targetMultiplier = 0.85; // 15% 감소
                    const baseMultiplier = currentGaugeLevel === 2 ? gauge2BaseMultiplier : gauge4BaseMultiplier;
                    platformSizeMultiplier = baseMultiplier - (sizeChangeProgress * (baseMultiplier - baseMultiplier * targetMultiplier));
                } else {
                    // 크기 변경 완료
                    const baseMultiplier = currentGaugeLevel === 2 ? gauge2BaseMultiplier : gauge4BaseMultiplier;
                    platformSizeMultiplier = baseMultiplier * 0.85;
                    platformSizeChangeActive = false;
                }
            }
        }
        
        // 체력 시스템 업데이트 함수
        function updateHealth() {
            if (gamePaused) return; // 라운드 종료 시 데미지 중단
            
            const now = Date.now();
            
            // 플레이어가 장판 밖에 있는지 확인
            const charCenterX = x + radius;
            const charCenterY = y + radius;
            const platformCenterX = platformX + (platformRadius * platformSizeMultiplier);
            const platformCenterY = platformY + (platformRadius * platformSizeMultiplier);
            
            const dx = charCenterX - platformCenterX;
            const dy = charCenterY - platformCenterY;
            const distanceToPlatform = Math.sqrt(dx * dx + dy * dy);
            const currentPlatformRadius = platformRadius * platformSizeMultiplier;
            
            const isOutsidePlatform = distanceToPlatform > currentPlatformRadius;
            
            // 장판 밖에 있으면 데미지 (0.1초 단위)
            if (isOutsidePlatform && now - lastDamageTime >= damageInterval) {
                let damage = 0;
                
                // 게이지 레벨에 따른 데미지 (0.1초당)
                if (currentGaugeLevel === 1 || currentGaugeLevel === 2) {
                    damage = 0.05; // 초당 0.5 데미지 = 0.1초당 0.05 데미지
                } else if (currentGaugeLevel === 3) {
                    damage = 0.075; // 초당 0.75 데미지 = 0.1초당 0.075 데미지
                } else if (currentGaugeLevel === 4) {
                    damage = 0.15; // 초당 1.5 데미지 = 0.1초당 0.15 데미지
                }
                
                currentHealth -= damage;
                lastDamageTime = now;
                
                if (currentHealth <= 0) {
                    currentHealth = 0;
                    // 플레이어 패배 - 라운드 종료
                    if (!isRoundEnded) {
                        endRound('enemy');
                    }
                }
            }
            
            // 상대(파란 원)가 장판 밖에 있는지 확인
            const blueCenterX = blueX + radius;
            const blueCenterY = blueY + radius;
            const blueDx = blueCenterX - platformCenterX;
            const blueDy = blueCenterY - platformCenterY;
            const blueDistanceToPlatform = Math.sqrt(blueDx * blueDx + blueDy * blueDy);
            const blueIsOutsidePlatform = blueDistanceToPlatform > currentPlatformRadius;
            
            // 상대 데미지 처리 (0.1초 단위)
            if (blueIsOutsidePlatform && now - lastEnemyDamageTime >= damageInterval) {
                let damage = 0;
                
                // 게이지 레벨에 따른 데미지 (0.1초당)
                if (currentGaugeLevel === 1 || currentGaugeLevel === 2) {
                    damage = 0.05; // 초당 0.5 데미지 = 0.1초당 0.05 데미지
                } else if (currentGaugeLevel === 3) {
                    damage = 0.075; // 초당 0.75 데미지 = 0.1초당 0.075 데미지
                } else if (currentGaugeLevel === 4) {
                    damage = 0.15; // 초당 1.5 데미지 = 0.1초당 0.15 데미지
                }
                
                enemyHealth -= damage;
                lastEnemyDamageTime = now;
                
                if (enemyHealth <= 0) {
                    enemyHealth = 0;
                    // 상대 패배 - 라운드 종료
                    if (!isRoundEnded) {
                        endRound('player');
                    }
                }
            }
            
            // 체력 게이지 업데이트: 빨간색(왼쪽), 파란색(오른쪽)
            // 호스트: 빨간색(자신) = currentHealth, 파란색(상대방) = enemyHealth
            // 게스트: 빨간색(상대방) = enemyHealth, 파란색(자신) = currentHealth
            if (isHost) {
                // 호스트: 왼쪽=빨간색(자신), 오른쪽=파란색(상대방)
                const redHealthPercent = Math.max(0, (currentHealth / maxHealth) * 100);
                const blueHealthPercent = Math.max(0, (enemyHealth / maxHealth) * 100);
                playerHealthFill.style.width = redHealthPercent + '%';
                enemyHealthFill.style.width = blueHealthPercent + '%';
            } else {
                // 게스트: 왼쪽=빨간색(상대방), 오른쪽=파란색(자신)
                const redHealthPercent = Math.max(0, (enemyHealth / maxHealth) * 100);
                const blueHealthPercent = Math.max(0, (currentHealth / maxHealth) * 100);
                playerHealthFill.style.width = redHealthPercent + '%';
                enemyHealthFill.style.width = blueHealthPercent + '%';
            }
        }
        
        // 라운드 종료 함수
        function endRound(winner) {
            if (isRoundEnded) return;
            
            isRoundEnded = true;
            gamePaused = true;
            roundEndReason = winner;
            
            // 승리 처리
            if (winner === 'player') {
                playerWins++;
            } else {
                enemyWins++;
            }
            
            // 멀티플레이어: 호스트가 라운드 종료를 게스트에게 알림
            if (isConnected && conn && isHost) {
                conn.send({
                    type: 'roundEnd',
                    winner: winner,
                    playerWins: playerWins,
                    enemyWins: enemyWins
                });
            }
            
            // 장판 숨기기
            lightPlatform.style.display = 'none';
            
            // 어두워지는 효과 제거
            character.style.filter = 'brightness(1.0)';
            blueCircle.style.filter = 'brightness(1.0)';
            
            // 플레이어 위치를 좌우 벽 쪽으로 이동
            const margin = 50; // 벽에서의 여백
            x = margin;
            y = window.innerHeight / 2 - characterSize / 2;
            blueX = window.innerWidth - characterSize - margin;
            blueY = y; // 플레이어와 같은 y축
            
            // 위치 즉시 적용
            character.style.left = x + 'px';
            character.style.top = y + 'px';
            blueCircle.style.left = blueX + 'px';
            blueCircle.style.top = blueY + 'px';
            
            // 목표 위치도 업데이트 (이동 방지)
            targetX = x;
            targetY = y;
            blueVelocityX = 0;
            blueVelocityY = 0;
            
            // 강화구슬 생성 및 표시
            showUpgradeOrbs();
        }
        
        // 강화구슬 표시 함수
        function showUpgradeOrbs() {
            // 기존 구슬 제거
            upgradeOrbsContainer.innerHTML = '';
            selectedOrbs = [];
            
            // 접촉 시간 맵 초기화
            orbContactTimes.clear();
            
            // 강화구슬 3개 생성 (랜덤 효과)
            const orbEffects = [
                { name: 'Speed Boost', value: 1.2 },
                { name: 'Health Boost', value: 2 },
                { name: 'Dash Cooldown', value: 0.8 },
                { name: 'Damage Reduction', value: 0.8 },
                { name: 'Platform Size', value: 1.1 }
            ];
            
            // 랜덤으로 3개 선택
            const selectedEffects = [];
            const availableEffects = [...orbEffects];
            for (let i = 0; i < 3; i++) {
                const randomIndex = Math.floor(Math.random() * availableEffects.length);
                selectedEffects.push(availableEffects[randomIndex]);
                availableEffects.splice(randomIndex, 1);
            }
            
            // 구슬 배치 (삼각형으로 화면 중앙에 배치)
            selectedEffects.forEach((effect, index) => {
                const orb = document.createElement('div');
                orb.className = 'upgradeOrb';
                orb.dataset.effect = effect.name;
                orb.dataset.value = effect.value;
                
                // 화면 중앙에 삼각형으로 배치
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const triangleSize = 120; // 삼각형 크기
                
                let orbX, orbY;
                if (index === 0) {
                    // 위쪽 구슬
                    orbX = centerX;
                    orbY = centerY - triangleSize;
                } else if (index === 1) {
                    // 왼쪽 아래 구슬
                    orbX = centerX - triangleSize * Math.cos(Math.PI / 6);
                    orbY = centerY + triangleSize * Math.sin(Math.PI / 6);
                } else {
                    // 오른쪽 아래 구슬
                    orbX = centerX + triangleSize * Math.cos(Math.PI / 6);
                    orbY = centerY + triangleSize * Math.sin(Math.PI / 6);
                }
                
                // 구슬의 중심이 정확히 위치하도록 조정
                orb.style.left = (orbX - 30) + 'px';
                orb.style.top = (orbY - 30) + 'px';
                
                // 초기 크기 설정
                orb.style.transform = 'scale(1.0)';
                
                upgradeOrbsContainer.appendChild(orb);
            });
            
            // 라운드 종료 화면 표시
            roundEndScreen.style.display = 'flex';
            
            // 진 플레이어부터 선택 시작
            selectionTurn = roundEndReason === 'player' ? 'enemy' : 'player';
            waitingForSelection = true;
        }
        
        // 구슬 선택 확인 함수
        function checkOrbSelection() {
            if (!waitingForSelection || selectedOrbs.length >= 2) return;
            
            const orbs = document.querySelectorAll('.upgradeOrb');
            const currentPlayer = selectionTurn === 'player' ? character : blueCircle;
            const now = Date.now();
            
            // 플레이어의 화면 좌표 계산
            const playerRect = currentPlayer.getBoundingClientRect();
            const playerCenterX = playerRect.left + playerRect.width / 2;
            const playerCenterY = playerRect.top + playerRect.height / 2;
            
            orbs.forEach(orb => {
                const orbRect = orb.getBoundingClientRect();
                const orbCenterX = orbRect.left + orbRect.width / 2;
                const orbCenterY = orbRect.top + orbRect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(playerCenterX - orbCenterX, 2) + 
                    Math.pow(playerCenterY - orbCenterY, 2)
                );
                
                // 구슬에 닿았는지 확인
                const isInContact = distance < 50;
                
                if (isInContact) {
                    // 접촉 시작 시간이 없으면 기록
                    if (!orbContactTimes.has(orb)) {
                        orbContactTimes.set(orb, now);
                    }
                    
                    // 접촉 시간 확인
                    const contactStartTime = orbContactTimes.get(orb);
                    const contactDuration = now - contactStartTime;
                    
                    // 접촉 진행도 계산 (0.0 ~ 1.0)
                    const contactProgress = Math.min(1.0, contactDuration / orbSelectionDuration);
                    
                    // 접촉 진행도에 따라 크기 조정 (1.0 -> 0.75, 25% 감소)
                    const minScale = 0.75; // 최소 크기 (25% 감소)
                    const currentScale = 1.0 - (contactProgress * (1.0 - minScale));
                    orb.style.transform = `scale(${currentScale})`;
                    
                    // 2초 이상 닿아있으면 선택
                    if (contactDuration >= orbSelectionDuration) {
                        // 빛나는 효과 생성
                        const flash = document.createElement('div');
                        flash.className = 'orbFlash';
                        
                        // 구슬의 색깔 가져오기 (배경 그라데이션에서 색상 추출)
                        const computedStyle = window.getComputedStyle(orb);
                        const bgColor = computedStyle.backgroundImage;
                        // 그라데이션에서 색상 추출 (간단한 방법: 보라색 계열 사용)
                        const orbColor = 'rgba(200, 150, 255, 0.6)'; // 구슬의 주요 색상
                        flash.style.background = `radial-gradient(circle, ${orbColor}, transparent)`;
                        flash.style.boxShadow = `0 0 70px ${orbColor}, 0 0 100px ${orbColor}`;
                        
                        // 구슬 위치에 빛나는 효과 배치
                        flash.style.left = orbCenterX + 'px';
                        flash.style.top = orbCenterY + 'px';
                        upgradeOrbsContainer.appendChild(flash);
                        
                        // 애니메이션 종료 후 제거
                        setTimeout(() => {
                            flash.remove();
                        }, 500);
                        
                        selectedOrbs.push({
                            player: selectionTurn,
                            effect: orb.dataset.effect,
                            value: parseFloat(orb.dataset.value)
                        });
                        
                        // 접촉 시간 기록 제거
                        orbContactTimes.delete(orb);
                        
                        // 선택된 구슬의 인덱스 찾기 (동기화용)
                        const allOrbs = Array.from(document.querySelectorAll('.upgradeOrb'));
                        const orbIndex = allOrbs.indexOf(orb);
                        
                        // 멀티플레이어: 구슬 선택 동기화
                        if (isConnected && conn) {
                            conn.send({
                                type: 'orbSelected',
                                orbIndex: orbIndex,
                                player: selectionTurn,
                                effect: orb.dataset.effect,
                                value: parseFloat(orb.dataset.value)
                            });
                        }
                        
                        // 선택된 구슬 제거
                        orb.remove();
                        
                        // 다음 플레이어 차례로 변경
                        if (selectedOrbs.length === 1) {
                            selectionTurn = roundEndReason === 'player' ? 'player' : 'enemy';
                        } else {
                            // 두 플레이어 모두 선택 완료 - 다음 라운드 시작
                            waitingForSelection = false;
                            startNextRound();
                        }
                    }
                } else {
                    // 구슬에서 멀어지면 접촉 시간 리셋 및 크기 복원
                    if (orbContactTimes.has(orb)) {
                        orbContactTimes.delete(orb);
                    }
                    // 빠르게 원래 크기로 복원 (transition이 적용됨)
                    orb.style.transform = 'scale(1.0)';
                }
            });
        }
        
        // 카운트다운 함수
        function startCountdown(callback) {
            gamePaused = true; // 카운트다운 중 게임 일시정지
            countdown.classList.add('active');
            
            let count = 3;
            countdownNumber.textContent = count;
            countdownText.textContent = '라운드 시작';
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    // 애니메이션 재시작을 위해 클래스 제거 후 추가
                    countdownNumber.style.animation = 'none';
                    setTimeout(() => {
                        countdownNumber.style.animation = '';
                    }, 10);
                } else {
                    countdownNumber.textContent = 'GO!';
                    countdownText.textContent = '';
                    clearInterval(countdownInterval);
                    
                    setTimeout(() => {
                        countdown.classList.remove('active');
                        // 카운트다운 종료 시 현재 위치를 목표 위치로 설정하여 순간이동 방지
                        targetX = x;
                        targetY = y;
                        gamePaused = false; // 카운트다운 종료 후 게임 재개
                        if (callback) callback();
                    }, 500);
                }
            }, 1000);
        }
        
        // 다음 라운드 시작 함수
        function startNextRound() {
            // 승리 조건 확인
            if (playerWins >= 3) {
                alert('플레이어 승리!');
                resetGame();
                return;
            }
            if (enemyWins >= 3) {
                alert('상대 승리!');
                resetGame();
                return;
            }
            
            // 라운드 종료 화면 숨기기
            roundEndScreen.style.display = 'none';
            
            // 다음 라운드로
            currentRound++;
            roundInfo.textContent = `Round ${currentRound}`;
            
            // 게임 상태 리셋
            isRoundEnded = false;
            gamePaused = false;
            
            // 체력 회복
            currentHealth = maxHealth;
            enemyHealth = maxHealth;
            playerHealthFill.style.width = '100%';
            enemyHealthFill.style.width = '100%';
            
            // 장판 다시 표시
            lightPlatform.style.display = 'block';
            
            // 게이지 리셋
            gauge1Completed = false;
            gauge2Completed = false;
            gauge3Completed = false;
            gauge4Completed = false;
            
            // 게이지 UI 리셋 (width를 0%로 설정)
            topGauge1.style.width = '0%';
            topGauge2.style.width = '0%';
            topGauge3.style.width = '0%';
            topGauge4.style.width = '0%';
            
            // 장판 효과 리셋
            platformSizeMultiplier = 1.0;
            platformSpeedMultiplier = 1.0;
            platformSizeChangeActive = false;
            gauge2SizeReduced = false;
            gauge4SizeReduced = false;
            currentGaugeLevel = 1;
            
            // 게이지 진행도 변수 리셋 (다음 업데이트를 위해)
            // gaugeXProgress 변수는 updateTopGauges 함수 내에서 지역 변수로 선언되므로 자동으로 리셋됨
            
            // 위치 리셋 (멀티플레이어 모드 고려)
            const pos = initializePosition();
            x = pos.x;
            y = pos.y;
            targetX = x;
            targetY = y;
            blueX = pos.blueX;
            blueY = pos.blueY;
            blueVelocityX = 0;
            blueVelocityY = 0;
            character.style.left = x + 'px';
            character.style.top = y + 'px';
            blueCircle.style.left = blueX + 'px';
            blueCircle.style.top = blueY + 'px';
            
            // 멀티플레이어: 초기 위치 즉시 동기화
            if (isConnected && conn) {
                conn.send({
                    type: 'position',
                    x: x,
                    y: y
                });
            }
            
            platformX = window.innerWidth / 2 - platformRadius;
            platformY = window.innerHeight / 2 - platformRadius;
            lightPlatform.style.left = platformX + 'px';
            lightPlatform.style.top = platformY + 'px';
            
            // 장판 크기 업데이트 (리셋된 크기로)
            const platformDisplaySize = platformSize * platformSizeMultiplier;
            lightPlatform.style.width = platformDisplaySize + 'px';
            lightPlatform.style.height = platformDisplaySize + 'px';
            
            // 빛 장판 방향 초기화
            platformDirectionX = (Math.random() - 0.5) * 2;
            platformDirectionY = (Math.random() - 0.5) * 2;
            dirLength = Math.sqrt(platformDirectionX * platformDirectionX + platformDirectionY * platformDirectionY);
            platformDirectionX /= dirLength;
            platformDirectionY /= dirLength;
            platformDirectionChangeTime = Date.now();
            platformDirectionDuration = 5000 + Math.random() * 5000;
            
            // 카운트다운 시작
            startCountdown(() => {
                // 카운트다운 완료 후 게이지 시작 시간 설정 (카운트다운이 끝난 시점부터 시작)
                const now = Date.now();
                topGauge1StartTime = now;
                topGauge2StartTime = now + topGaugeDuration;
                topGauge3StartTime = now + topGaugeDuration * 2;
                topGauge4StartTime = now + topGaugeDuration * 3;
                
                // 멀티플레이어: 호스트가 라운드 시작을 게스트에게 알림 (카운트다운 후 위치 포함)
                if (isConnected && conn && isHost) {
                    conn.send({
                        type: 'roundStart',
                        currentRound: currentRound,
                        playerWins: playerWins,
                        enemyWins: enemyWins,
                        hostX: x,
                        hostY: y
                    });
                }
            });
        }
        
        // 게임 리셋 함수
        function resetGame() {
            currentRound = 1;
            playerWins = 0;
            enemyWins = 0;
            roundInfo.textContent = `Round ${currentRound}`;
            startNextRound();
        }

        // 멀티플레이어 데이터 전송
        let lastSyncTime = 0;
        const syncInterval = 50; // 50ms마다 동기화
        let lastGameStateSyncTime = 0;
        const gameStateSyncInterval = 100; // 100ms마다 게임 상태 동기화 (호스트만)
        
        function syncMultiplayerData() {
            if (!isConnected || !conn) return;
            
            const now = Date.now();
            
            // 플레이어 위치 및 체력 전송 (모든 플레이어)
            if (now - lastSyncTime >= syncInterval) {
                lastSyncTime = now;
                
                conn.send({
                    type: 'position',
                    x: x,
                    y: y
                });
                
                conn.send({
                    type: 'health',
                    health: currentHealth
                });
            }
            
            // 게임 상태 전송 (호스트만)
            if (isHost && now - lastGameStateSyncTime >= gameStateSyncInterval) {
                lastGameStateSyncTime = now;
                
                // 게이지 진행도 계산
                const gaugeNow = Date.now();
                let gauge1Progress = gauge1Completed ? 100 : Math.min(100, ((gaugeNow - topGauge1StartTime) / topGaugeDuration) * 100);
                let gauge2Progress = gauge2Completed ? 100 : Math.min(100, ((gaugeNow - topGauge2StartTime) / topGaugeDuration) * 100);
                let gauge3Progress = gauge3Completed ? 100 : Math.min(100, ((gaugeNow - topGauge3StartTime) / topGaugeDuration) * 100);
                let gauge4Progress = gauge4Completed ? 100 : Math.min(100, ((gaugeNow - topGauge4StartTime) / topGaugeDuration) * 100);
                
                conn.send({
                    type: 'gameState',
                    platformX: platformX,
                    platformY: platformY,
                    platformSizeMultiplier: platformSizeMultiplier,
                    platformSpeedMultiplier: platformSpeedMultiplier,
                    currentGaugeLevel: currentGaugeLevel,
                    topGauge1StartTime: topGauge1StartTime,
                    topGauge2StartTime: topGauge2StartTime,
                    topGauge3StartTime: topGauge3StartTime,
                    topGauge4StartTime: topGauge4StartTime,
                    gauge1Completed: gauge1Completed,
                    gauge2Completed: gauge2Completed,
                    gauge3Completed: gauge3Completed,
                    gauge4Completed: gauge4Completed,
                    gauge1Progress: gauge1Progress,
                    gauge2Progress: gauge2Progress,
                    gauge3Progress: gauge3Progress,
                    gauge4Progress: gauge4Progress
                });
            }
        }
        
        // 게임 루프
        function gameLoop() {
            // 플레이어 이동은 항상 가능 (구슬 선택을 위해)
            updatePosition();
            
            if (!gamePaused) {
                updateGauge();
                
                // 게임 상태 업데이트는 호스트만 수행 (멀티플레이어 모드)
                if (isHost || !isConnected) {
                    updateLightPlatform();
                    updateTopGauges();
                }
                
                updateHealth();
            }
            
            // 멀티플레이어 데이터 동기화
            if (isConnected) {
                syncMultiplayerData();
            }
            
            // 구슬 선택 확인 (라운드 종료 시)
            if (waitingForSelection) {
                checkOrbSelection();
            }

            requestAnimationFrame(gameLoop);
        }

        // 초기화 함수
        function init() {
            // 초기 위치 재설정 (멀티플레이어 모드 고려)
            const pos = initializePosition();
            x = pos.x;
            y = pos.y;
            prevX = x;
            prevY = y;
            targetX = x;
            targetY = y;
            velocityX = 0;
            velocityY = 0;
            
            // 캐릭터 초기 위치 설정
            character.style.left = x + 'px';
            character.style.top = y + 'px';
            
            // 파란색 원 초기 위치 설정 (initializePosition에서 반환된 값 사용)
            blueX = pos.blueX;
            blueY = pos.blueY;
            blueVelocityX = 0;
            blueVelocityY = 0;
            blueCircle.style.left = blueX + 'px';
            blueCircle.style.top = blueY + 'px';
            
            // 빛 장판 초기 위치 설정 (화면 중앙)
            platformX = window.innerWidth / 2 - platformRadius;
            platformY = window.innerHeight / 2 - platformRadius;
            lightPlatform.style.left = platformX + 'px';
            lightPlatform.style.top = platformY + 'px';
            
            // 장판 크기 업데이트
            const platformDisplaySize = platformSize * platformSizeMultiplier;
            lightPlatform.style.width = platformDisplaySize + 'px';
            lightPlatform.style.height = platformDisplaySize + 'px';
            
            // 빛 장판 방향 초기화
            platformDirectionX = (Math.random() - 0.5) * 2;
            platformDirectionY = (Math.random() - 0.5) * 2;
            dirLength = Math.sqrt(platformDirectionX * platformDirectionX + platformDirectionY * platformDirectionY);
            platformDirectionX /= dirLength;
            platformDirectionY /= dirLength;
            platformDirectionChangeTime = Date.now();
            platformDirectionDuration = 5000 + Math.random() * 5000;
            
            // 초기 게이지 상태: 돌진 가능 상태 (하얀색 게이지 완전히 채워짐)
            updateGauge();
            
            // 체력 초기화
            currentHealth = maxHealth;
            enemyHealth = maxHealth;
            playerHealthFill.style.width = '100%';
            enemyHealthFill.style.width = '100%';
            
            // 게임 루프 시작
            gameLoop();
        }

        // 게임 UI 요소들
        const topGaugeElements = document.querySelectorAll('.topGauge');
        const healthGaugeElements = document.querySelectorAll('.healthGauge');
        
        // 방 만들기 버튼 클릭 이벤트 (메인 화면)
        // 방 만들기 버튼 클릭 이벤트 (메인 화면)
        createRoomMainButton.addEventListener('click', () => {
            mainMenu.classList.add('hidden');
            multiplayerMenu.classList.add('active');
            createRoomSection.style.display = 'block';
            joinRoomSection.style.display = 'none';
            createRoomButton.style.display = 'none';
            waitingSection.style.display = 'block';
            createRoom();
        });
        
        // 방 입장하기 버튼 클릭 이벤트 (메인 화면)
        joinRoomMainButton.addEventListener('click', () => {
            // 멀티플레이어 메뉴 표시
            mainMenu.classList.add('hidden');
            multiplayerMenu.classList.add('active');
            createRoomSection.style.display = 'none';
            joinRoomSection.style.display = 'block';
            roomCodeInput.focus();
        });
    </script>
</body>
</html>
